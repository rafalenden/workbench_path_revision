<?php

/**
 * Implements hook_node_load().
 */
function workbench_path_revision_node_load($nodes, $types) {
  $nids = array();
  foreach ($nodes as $node) {
    // Remove nodes that are not moderated.
    if (workbench_moderation_node_type_moderated($node->type)) {
      $nids[] = $node->nid;
    }
  }

  // Add information about path revision to node object.
  $path_revisions = workbench_path_revision_load_multiple($nids);
  foreach ($path_revisions as $langcode => $path_revision) {
    $node = &$nodes[$path_revision['nid']];
    $node->workbench_path_revision[$path_revision['language']] = $path_revision;
    if (entity_language('node', $node) == $path_revision['language']) {
      $node->path['pathauto'] = (bool) $path_revision['pathauto'];
      if (!empty($path_revision['alias'])) {
        $node->path['alias'] = $path_revision['alias'];
      }
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 */
function workbench_path_revision_form_node_form_alter(&$form, $form_state) {
  $node = &$form_state['node'];

  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  $entity_language = entity_language('node', $node);

  // Because workbench_moderation overrides page callback for "node/%node/edit"
  // information about path has to be added here.
  if (isset($node->workbench_path_revision[$entity_language]['pathauto']) && isset($form['path']['alias'])) {
    $form['path']['pathauto']['#default_value'] = $node->workbench_path_revision[$entity_language]['pathauto'];
  }
  if (!empty($node->workbench_path_revision[$entity_language]['alias']) && isset($form['path']['alias'])) {
    $form['path']['alias']['#default_value'] = $node->workbench_path_revision[$entity_language]['alias'];
  }
}

/**
 * Update aliases of node for all translations when node is being published.
 */
function workbench_path_revision_update_live_aliases($node) {
  $current_node_aliases = db_select('url_alias')
    ->condition('source', 'node/' . $node->nid)
    ->fields('url_alias')
    ->execute()
    ->fetchAllAssoc('language', PDO::FETCH_ASSOC);

  foreach ($node->workbench_path_revision as $langcode => $path_revision) {
    $path = array(
      'language' => $langcode,
      'alias' => $path_revision['alias'],
      'source' => 'node/' . $node->nid,
    );

    if (isset($current_node_aliases[$langcode])) {
      $path['pid'] = $current_node_aliases[$langcode]['pid'];
    }

    // Pathauto is on
    if ($path_revision['pathauto']) {
      $translated_node = clone $node;
      $translated_node->path = $path;
      $options = array(
        'language' => $langcode,
      );

      pathauto_node_update_alias($translated_node, 'update', $options);
    }
    // Pathauto is off
    else {
      path_save($path);
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function workbench_path_revision_node_presave($node) {
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  $node_language = entity_language('node', $node);

  // Check if other modules didn't override path data.
  if (empty($node->workbench_path_revision[$node_language]['overridden']) || !isset($node->workbench_path_revision[$node_language])) {
    $node->workbench_path_revision[$node_language]['pathauto'] = isset($node->path['pathauto'])
      ? (int) $node->path['pathauto'] : 1;
    $node->workbench_path_revision[$node_language]['alias'] = isset($node->path['pathauto']) && empty($node->path['pathauto'])
      ? $node->path['alias'] : '';
    $node->workbench_path_revision[$node_language]['language'] = $node_language;
  }

  // Block saving URL aliases.
  if (isset($node->workbench_path_revision)) {
    $node->path = array('alias' => '', 'pathauto' => 0);
  }

  // Update aliases for other translations.
  // 'updating_live_revision' is set only if executed from workbench_moderation_store()
  if (isset($node->workbench_moderation['current']->state) && $node->workbench_moderation['current']->state == 'published' && !empty($node->workbench_moderation['updating_live_revision'])) {
    workbench_path_revision_update_live_aliases($node);
  }
}

/**
 * Implements hook_node_insert().
 */
function workbench_path_revision_node_insert($node) {
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  workbench_path_revision_node_update($node);
}

/**
 * Implements hook_node_update().
 */
function workbench_path_revision_node_update($node) {
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  foreach ($node->workbench_path_revision as $path_revision) {
    $path_revision['nid'] = $node->nid;
    $path_revision['vid'] = $node->vid;
    workbench_path_revision_save($path_revision);
  }
}

/**
 * Implements hook_node_delete().
 */
function workbench_path_revision_node_delete($node) {
  db_delete('workbench_path_revision')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Save the path revision for node.
 *
 * @param $entity
 *   The node object.
 * @param $path_revision
 */
function workbench_path_revision_save($path_revision) {
  db_merge('workbench_path_revision')
    ->key(array(
      'nid' => $path_revision['nid'],
      'vid' => $path_revision['vid'],
      'language' => $path_revision['language'],
    ))
    ->fields(array(
      'nid' => $path_revision['nid'],
      'vid' => $path_revision['vid'],
      'language' => $path_revision['language'],
      'alias' => $path_revision['alias'],
      'pathauto' => $path_revision['pathauto'],
    ))
    ->execute();
}

/**
 * Load a pathauto state for an entity.
 *
 * @param $vid
 *   The node revision ID.
 * @param $conditions
 *   An associative array of conditions on the {workbench_path_revision}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 *
 * @return array
 *   Path revision from DB.
 */
function workbench_path_revision_load($vid, $conditions = array()) {
  $path_revision = workbench_path_revision_load_multiple(array($vid), $conditions);
  return !empty($path_revision) ? reset($path_revision) : FALSE;
}

/**
 * Load a pathauto state for multiple entities.
 *
 * @param $nids
 *   An array of node NIDs.
 * @param $conditions
 *   An associative array of conditions on the {workbench_path_revision}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 *
 * @return array
 *   Array of path revisions from DB.
 */
function workbench_path_revision_load_multiple($nids, $conditions = NULL) {
  if (!$nids) {
    return array();
  }

  $query = db_select('workbench_path_revision', 'pr')
    ->fields('pr')
    ->condition('nid', $nids)
    ->orderBy('vid', 'ASC');

  // Add conditions.
  if ($conditions) {
    foreach ($conditions as $field => $value) {
      $query->condition($field, $value);
    }
  }

  return $query
    ->execute()
    ->fetchAllAssoc('language', PDO::FETCH_ASSOC);
}

/**
 * Disable path for given node translation from being updated.
 *
 * @param object $node
 *   Node object.
 * @param $langcode
 *   Language of path that will be prevented from updating.
 */
function workbench_path_revision_disable_path_update($node, $langcode, $old_alias = NULL) {
  $node->workbench_path_revision[$langcode]['pathauto'] = 0;
  if ($langcode == $node->path['language']) {
    $old_alias = $node->path['alias'];
  }
  elseif (empty($old_alias)) {
    $old_path = path_load(array(
      'source' => "node/$node->nid",
      'language' => $langcode,
    ));
    $old_alias = $old_path['alias'];
  }
  $node->workbench_path_revision[$langcode]['alias'] = $old_alias;
  $node->workbench_path_revision[$langcode]['overridden'] = TRUE;

  if ($node->vid == $node->workbench_path_revision[$langcode]->vid) {
    $node->path['pathauto'] = 0;
  }
}

/**
 * Implements hook_redirect_presave().
 *
 * @see https://drupal.org/node/1945558#comment-7500630
 */
function workbench_path_revision_redirect_presave($redirect) {
  // Creating automatic redirects is disabled.
  if (!variable_get('redirect_auto_redirect', TRUE)) {
    return;
  }

  // Remove redirects pointing to aliases of the node it handles.
  $query = db_select('url_alias', 'u')
    ->fields('u', array('alias'));
  $query->join('redirect', 'r', 'u.alias = r.source');
  $query->fields('r', array('rid'));
  $results = $query->execute();

  foreach ($results as $record) {
    db_delete('redirect')
      ->condition('rid', $record->rid)
      ->execute();
  }
}
